\chapter{Mining Fingerprints using Dynamic Program Analysis}
\label{chapter:dynamic}

This chapter presents the use of dynamic program analysis to mine fingerprints
of security-sensitive operations. In particular, it presents a technique that
makes novel use of tangible side-effects to locate fingerprints in runtime
execution traces of a program. It also presents an application of this
technique to mine fingerprints of security-sensitive operations for the
\xserver.

%------------------------------------------------------------------------------
\section{Problem statement}
\label{chapter:dynamic:problem}

Given a server program, and a description of the security-sensitive operations
that clients can request the server to perform, the technique presented in this
chapter outputs fingerprints of these security-sensitive operations. 

This chapter thus assumes that the set of security-sensitive operations is
known \apriori. The description can be informal, and must describe the
high-level intent of the security-sensitive operation.  For example, the
document by Kilpatrick~\etal~\cite{ksv03} contains such descriptions for $59$
security-sensitive operations on different resources managed by the \xserver,
such as \code{Window}s, \code{Font}s and \code{Color}s. This document
describes, for instance, the \op{Window\_Map} security-sensitive operation as
the action of mapping a window to the screen and the \op{Window\_Enumerate} 
operation as the action of listing child windows.

Because a fingerprint characterizes the resource accesses performed by a
security-sensitive operation, the technique presented here offers a way to
formalize an informal description of security-sensitive operations. This
technique is motivated by current practice in retrofitting code, where the
aforementioned informal descriptions are also used to locate where code
performs these security-sensitive operations (see, for example,
\cite[Sections~5.2 and~5.3]{ksv03}). 


%------------------------------------------------------------------------------
\section{Identifying fingerprints using analysis of program traces}
\label{chapter:dynamic:fingerprint}

How can informal descriptions of security-sensitive operations be converted
into precise code-level descriptions (\ie~fingerprints) of these operations?
We present two novel observations that enable us to do so.

\begin{observation}[Tangible side-effects]
%
Security-sensitive operations are typically associated with observable change
in the system state---these changes will be refered to as \textit{tangible
side-effects}.
%
\end{observation}

Tangible side-effects help us determine whether a server has performed a
security-sensitive operation. Thus, if we induce the server to perform a
security-sensitive operation, \ie~the occurrence of a tangible side-effect
denotes that the operation is performed, then the resource accesses associated
with that security-sensitive operation \textit{must} be in the trace generated
by the server.  Thus, identifying fingerprints reduces to tracing the server as
it performs a tangible side-effect, and recording accesses to resources as it
does so. Each trace records function calls, and reads and writes to resources
as well as the functions in which they were performed. In particular, each
trace records resource accesses using the \textit{Write}, \textit{Read} and
\textit{Call} code patterns, shown in \figref{figure:fingerprint-definition}.

However, the program trace generated by the server, even in a controlled
experiment to perform a tangible side-effect, may be huge. For example, using 
our tracing infrastructure, the \xserver\ generates a trace of length $10459$
when the following experiment is performed: start the \xserver, open an
\code{xterm}, close the \code{xterm}, and close the \xserver\ (each of these is
a tangible side-effect). It is infeasible to identify succinct fingerprints of
security-sensitive operations (\eg~those of \op{Window\_Create} and
\op{Window\_Destroy}) by studying this trace.  Our second observation addresses
this problem.

\begin{observation}[Comparing traces]
%
The fingerprint of a security-sensitive operation can be localized by comparing
traces generated by server executions that perform a security-sensitive
operation against traces generated by executions that do not.
%
\end{observation}

The key idea underlying this observation is that if an execution of the server
does not perform a security-sensitive operation, then the trace produced by the
server will not contain a fingerprint of that operation.  For example, the
trace $T_{open}$ that opens an \xclient\ window on the \xserver\ will contain
the fingerprint of \op{Window\_Create}, but the trace $T_{close}$ that closes a
window will not. Thus, $T_{open}$ - $T_{close}$, a shorter trace, still
contains the fingerprint of \op{Window\_Create}. Continuing this process with
other traces that do not perform \op{Window\_Create} reduces the size of the
trace to be examined even further. In fact, for the \xserver\ we were able to
reduce the size of the trace several-fold using this technique (see
\tabref{table:aid-experiments} and \tabref{table:set-equations}), whittling
down the search for fingerprints to about $15$ functions, on average.

A technical difficulty must be addressed before we compare traces. A tangible 
side-effect may be associated with multiple security-sensitive operations, and 
all the security-sensitive operations associated with it must be identified. 
For instance, when an \code{xterm} window is opened on the \xserver, the 
security-sensitive operations include (amongst others) creating a window 
(\op{Window\_Create}), mapping it to the screen (\op{Window\_Map}), and 
initializing several window attributes (\op{Window\_Setattr}).  

We manually identify the security-sensitive operations associated with each
tangible side-effect.  Because the side-effects we consider are
\textit{tangible}, programmers typically have an intuitive understanding of the
operations involved in performing the side-effect. The trace generated by the
tangible side-effect is then assigned a \textit{label} with the set of
security-sensitive operations that it performs. It is important to note that
tangible side-effects are not specific to the \xserver\ alone, and are
applicable to other servers as well.  For example, in a database server,
dropping or adding a record, changing fields of records, and performing table
joins are tangible side-effects.  Because labeling traces is a manual process,
it is conceivable that they are not labeled correctly. However we show
empirically that fingerprints can be identified succinctly and precisely,
\textit{in spite of errors in labeling}.  Because each trace can be associated
with multiple security-sensitive operations, we formulate
\textit{set equations} for each operation in terms of the labels of our traces.

\begin{definition}[Set equation]
\label{definition:set-equation}
Given set $S$, a set $B\subseteq$$S$, and a collection $\mathcal{C}$=\{C$_1$,
C$_2$, $\ldots$, C$_n$\} of subsets of $S$, a set equation for $B$ is
$B$=$C_{j_1}$*$C_{j_2}$*$\ldots$*$C_{j_k}$, where each $C_{j_i}$ is an element,
or the complement of an element of $\mathcal{C}$, and `*' is $\cup$ or $\cap$.
\end{definition}

To find a fingerprint for an operation \op{OP}, we do the following: Let $S$ be
the set of all security-sensitive operations, and $B$ = \{\op{OP}\}.  Let C$_i$
denote the label (\ie~the set of security sensitive operations performed) of
trace T$_i$, which is obtained when the server performs the tangible
side-effect \textit{seff$_i$}. Formulate a set equation for $B$ in terms of
C$_i$'s, and apply the \textit{same set-operations} on the set of code patterns
in the corresponding T$_i$'s. The resulting set of code patterns is the
fingerprint for \op{OP}. 

For example, if T$_1$ is a trace that performs \op{OP} and \op{OP$^\prime$},
and T$_2$ is a trace that performs \op{OP$^\prime$}, then C$_1$ = \{\op{OP},
\op{OP$^\prime$}\}, and C$_2$ = \{\op{OP$^\prime$}\}. Say T$_1$ contains the
set of code patterns \{$p_1$, $p_2$\}, and T$_2$ contains the set of code
patterns \{$p_2$\}. Then to find the fingerprint of \op{OP}, we let $B$ =
\{\op{OP}\}, and observe that $B$ = C$_1$ - C$_2$. We perform the \textit{same}
set-operations on the set of code patterns in T$_1$ and T$_2$ to obtain
\{$p_1$\}, which is then reported as the fingerprint of \op{OP}. This process
is formalized in \aref{algorithm:dynamic-fingerprint-mining}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\restylealgo{boxed}
\linesnumbered
\begin{algorithm}[ht!]
%
\SetVline
\KwName{\algoname{Find\_Fingerprint}{(\server, $S$, Seff)}}
%
\KwIn{
(i)~\server: Server to be retrofitted,\\
(ii)~$S$: A set of security-sensitive operations 
\{\op{OP}$_1$, $\ldots$, \op{OP}$_n$\}, and\\
(iii)~\textit{Seff}: A set of tangible side-effects \{\textit{seff$_1$},~$\ldots$,~\textit{seff$_m$}\}.
}
%
\KwOut{FP$_1$, $\ldots$, FP$_n$ : Each FP$_i$ is the fingerprint of the
security-sensitive operation \op{OP}$_i$.}
%
\server$^\prime$ := \server\ instrumented to perform tracing\;
\nllabel{line:start}
%
\ForEach{(tangible side-effect \textit{seff$_i$} $\in$ \textit{Seff})}{
  T$_i$ := Trace generated by \server$^\prime$ when induced to perform~\textit{seff$_i$}\;
  $label$(T$_i$) := Set of operations (from $S$) involved in \textit{seff$_i$}\;    
\nllabel{line:finishlabeling}
}
%
\ForEach{(\op{OP}$_i$ $\in$ $S$)}{
  \nllabel{line:startfingerprint}
  SE$_i$ := Set-equation for \op{OP}$_i$ in terms of $label$(T$_1$), $\ldots$,
  $label$(T$_m$)\;
  CPset$_i$ := Set of code patterns in T$_i$\;
  FP$_i$ := Result when the set operations in SE$_i$ are performed on 
            CPset$_1$,~$\ldots$,~CPset$_m$\; \nllabel{line:endfingerprint}
}
%
\Return FP$_1$, $\ldots$, FP$_n$
\mycaption{Dynamic program analysis-based algorithm to mine
fingerprints of security-sensitive operations.}{\label{algorithm:dynamic-fingerprint-mining}}
\end{algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Finding a set equation for a set B is equivalent to computing an \textit{exact
cover} for this set. An exact cover may not always exist; if one exists, it can
be computed efficiently. However, because each trace is manually labeled with
the set of security-sensitive operations that it performs (using tangible
side-effects to aid reasoning), these labels may potentially be erroneous.  We
would thus like to compute the smallest set equation for the set B.

Finding the smallest set equations is, in general, a hard problem. More
precisely, define a CNF set equation as a set equation expressed in conjunctive
normal form, with `$\cap$' and `$\cup$' as the conjunction and disjunction
operators, respectively. Each disjunct in the equation is a \textit{clause}.
The \kcnfse\ problem, which is equivalent to the problem of finding the smallest 
set equations, can be shown to be \textsf{NP}-complete.

\begin{definition}[\kcnfse]
Given a set $S$, a set $B~\subseteq$ $S$, a collection $\mathcal{C}$ of subsets
of $S$ (as in Definition~\ref{definition:set-equation}), and an integer $k$,
does $B$ have a CNF-set equation with at most $k$ clauses?
\end{definition}

We currently use a simple brute-force algorithm to find set equations. This
works for us, because the number of sets we have to examine (which is the
number of traces we gather) is fortunately quite small ($15$ for the \xserver).

%------------------------------------------------------------------------------
\section{Implementation}
\label{chapter:dynamic:implementation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BEGIN: Table with Aid's results for Window operations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[ht!]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|}
\hline 
\textbf{Trace name} & A &  B  & C  & D  &  E &  F & G  &  H & I\\\hline 
%
\shortstack{\textbf{Side-effect}\\$\longrightarrow$\\\\\\\textbf{Security-sensitive Operation}\\$\downarrow$} & 
\rot{\shortstack{open\\xterm}} & 
\rot{\shortstack{close\\xterm}} &
\rot{\shortstack{open\\browser}} & 
\rot{\shortstack{close\\browser}} & 
\rot{\shortstack{type to\\window}} & 
\rot{\shortstack{move\\window}}  & 
\rot{\shortstack{open \& close\\\texttt{twm} menu}} & 
\rot{\shortstack{switch\\windows}} & 
\rot{\shortstack{open menu\\(browser)}}\\\hline
%
\op{Window\_Create}     & \y &    & \y &    &    &    & \y &    & \y \\\hline
\op{Window\_Destroy}    &    & \y & \my& \y &    &    & \y & \my&    \\\hline
\op{Window\_Map}        & \y &    & \y &    &    &    & \y &    & \y \\\hline
\op{Window\_Unmap}      &    & \y & \my& \y &    &    & \y & \my&    \\\hline
\op{Window\_Chstack}    & \y &    & \y &    &    &    & \y & \y & \y \\\hline
\op{Window\_Getattr}    & \y &    & \y &    &    & \mn& \mn&    & \y \\\hline 
\op{Window\_Setattr}    & \y &    & \y &    &    & \y & \mn& \my& \y \\\hline
\op{Window\_Move}       &    &    & \my&    &    & \y &    & \my& \my\\\hline 
\op{Window\_Enumerate}  & \my& \my& \y & \y &    & \y & \my& \y & \y \\\hline
\op{Window\_InputEvent} &    &    &    &    & \y & \y & \y & \y & \y \\\hline
\op{Window\_DrawEvent}  & \y & \y & \y & \y & \my& \y & \y & \y & \y \\\hline\hline 
\shortstack{Distinct\\Functions}& $115$ & $148$ & $251$ & $161$ & $68$ &
$148$ & $96$ & $93$ & $166$ \\\hline
%
\end{tabular}
\end{center}

%% Raw trace: average length = $103987$
%% Raw trace for each side-effect: average length = 53829

\mycaption{Examples of labeled traces obtained from the \xserver. A ``\y'' 
entry in ({\em row}, {\em column}) denotes that the trace represented by 
{\em column} performs the security-sensitive operation represented by 
{\em row}. A ``\my'' or a ``\mn'' entry denotes a mistake in manual labeling.}
{\label{table:aid-experiments}}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% END: Table with Aid's results for Window operations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We have implemented \aref{algorithm:dynamic-fingerprint-mining} in a prototype
tool called \aid. We use a modified version of \code{gcc} to compile the
server. During compilation, instrumentation is inserted statically at statements 
that read and write to fields of data structures denoting resources that we
want to protect access to. We log the field and the data structure that was 
read from, or written to, and the function name, file name, and the line number 
at which this occurs. We then induce the modified server to perform a set of 
tangible side-effects, and proceed as in \aref{algorithm:dynamic-fingerprint-mining} 
to mine fingerprints.

We applied this to mine fingerprints of security-sensitive operations in the
\xserver. In particular, we recorded reads and writes to fields of data
structures such as \code{Client}, \code{Window}, \code{Font}, \code{Drawable},
\code{Input}, and \code{xEvent}.  \tabref{table:aid-experiments} shows the
result of performing lines (\ref{line:start})-(\ref{line:finishlabeling}) of
\aref{algorithm:dynamic-fingerprint-mining}.  Columns represent traces of $9$
tangible side-effects, and rows represent $11$ security-sensitive operations on
the \code{Window} data structure. We manually labeled each trace with the
security-sensitive operations that it performs. These entries are marked in
\tabref{table:aid-experiments} using \y\ and \mn. For example, opening an
\code{xterm} on the \xserver\ includes creating a window (\op{Window\_Create}),
mapping it onto the screen (\op{Window\_Map}), placing it appropriately in the
stack of windows that \xserver\ maintains (\op{Window\_Chstack}), getting and
setting its attributes (\op{Window\_Getattr}, \op{Window\_Setattr}), and
drawing the contents of the window (\op{Window\_DrawEvent}).  This trace of
operations contains $115$ calls to distinct functions in the \xserver, as shown
in the last row of \tabref{table:aid-experiments}.

\tabref{table:set-equations} and \figref{figure:fingerprints} show the result
of performing lines (\ref{line:startfingerprint})-(\ref{line:endfingerprint})
of \aref{algorithm:dynamic-fingerprint-mining} with the labeled traces obtained
above. For each operation, the set equation used to obtain fingerprints and the
size of the resulting set are shown in \tabref{table:set-equations}, while the 
set of fingerprints is shown in \figref{figure:fingerprints}. Note that each
security-sensitive operation can have more than one fingerprint, as for
example, is the case with \op{Window\_Enumerate} and \op{Window\_InputEvent}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN: Table with set equations.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[ht!]
\begin{center}
\begin{tabular}{|l|l|r|}
\hline
\textbf{Operation} & \textbf{Set Equation} & \textbf{$|$FP$|$}\\\hline
\op{Window\_Create}  
  & $\cap$(A, C, G) - D - H   
  & $9$ \\\hline
%
\op{Window\_Destroy} 
  & $\cap$(B, D) - A          
  & $7$ \\\hline
%
\op{Window\_Map}     
  & $\cap$(A, C, G) - D - H   
  & $9$ \\\hline
%
\op{Window\_Unmap}   
  & $\cap$(B, D) - A          
  & $7$  \\\hline
%
\op{Window\_Chstack} 
  & $\cap$(A, C, G, H, I) - D - E
  & $6$  \\\hline
%
\op{Window\_Getattr} 
  & $\cap$(A, C, I) - B - D - E - F        
  & $25$  \\\hline
%
\op{Window\_Setattr} 
  & $\cap$(A, C, F, I) - B - D - E       
  & $15$  \\\hline
%
\op{Window\_Move}    
  & F - A - B - D - E - G                 
  & $38$\\\hline
%
\op{Window\_Enumerate}  
  & $\cap$(C, D, F, H, I)  
  & $21$  \\\hline
%
\op{Window\_InputEvent} 
  & E - C                  
  & $19$ \\\hline
%
\op{Window\_DrawEvent} 
  & $\cap$(A, B, C, D, E, F, G, H, I) 
  & $12$ \\\hline
%
\multicolumn{2}{r}{\textbf{Average value of $|$FP$|$:}}
& \multicolumn{1}{l}{\textbf{15.3}}\\
%
\end{tabular}
\end{center}

\mycaption{Set equations for security-sensitive operations computed
using the annotations in \tabref{table:aid-experiments}, and the
sizes of the resulting sets.}{\label{table:set-equations}}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To find errors in manual labeling of traces, we did the following.  After
finding fingerprints of security-sensitive operations, we checked each trace
for the presence of these fingerprints. Presence of a fingerprint of a
security-sensitive operation in a trace that is not labeled with that
security-sensitive operation shows an error in manual labeling; such entries
are marked \my\ in \tabref{table:aid-experiments}. For example, we did not
label the trace generated by opening a browser (\code{htmlview}) with
\op{Window\_Unmap}. On the other hand, absence of fingerprints of a
security-sensitive operation in a trace that is labeled with the
security-sensitive operation also shows an error in manual labeling; such
entries are marked \mn\ in \tabref{table:aid-experiments}. Thus for example,
we did label the trace generated by moving a window with \op{Window\_Getattr},
whereas in fact, this operation is not performed when a window is moved.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN: Table with fingerprints.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[ht!]
\begin{center}
\begin{tabular}{|r l|}
\hline
\op{Window\_Create} :- 
  & \textit{Call}~\code{CreateWindow}\\
%
\hline
%
\op{Window\_Destroy} :-
  & \textit{Call}~\code{DeleteWindow}\\
%
\hline
%
\op{Window\_Map} :-
  & \textit{Write} \pred{True} \textit{To} \code{Window->mapped}\\
  & $\wedge$ \textit{Write} \code{MapNotify} \textit{To} \code{xEvent->union->type}\\
%
\hline
% NOTE (VG): From Call~MapWindow and Call~MapSubWindows
%
\op{Window\_Unmap} :-
  & \textit{Write} \code{UnmapNotify} \textit{To} \code{xEvent->union->type}\\
%
\hline
% NOTE (VG): From Call UnmapWindow and Call UnmapSubwindows
%
\op{Window\_Chstack} :-
  & \textit{Call}~\code{MoveWindowInStack}\\
%
\hline
%
\op{Window\_Getattr} :-
  & \textit{Call}~\code{GetWindowAttributes}\\
%
\hline
%
\op{Window\_Setattr} :-
  & \textit{Call}~\code{ChangeWindowAttributes}\\
%
\hline
%
\op{Window\_Move}    
  & \textit{Call}~\code{ProcTranslateCoords}\\
%
\hline
%
\op{Window\_Enumerate} :-
  & \textit{Read}~\code{WindowPtr->firstChild}\\
  & $\wedge$~\textit{Read}~\code{WindowPtr->nextSib}\\
  & $\wedge$~\code{WindowPtr$\neq$0}\\
%    
\op{Window\_Enumerate} :-
  & \textit{Read}~\code{WindowPtr->lastChild}\\
  & $\wedge$ \textit{Read}~\code{WindowPtr->prevSib}\\
%
\hline
% NOTE (VG): Based upon UnrealizeTree
%
\op{Window\_InputEvent} :-
  & \textit{Call}~\code{CoreProcessPointerEvent}\\
%
\op{Window\_InputEvent} :-
  &  \textit{Call}~\code{CoreProcessKeyboardEvent}\\
%
\op{Window\_InputEvent} :-
  & \textit{Call}~\code{xf86eqProcessInputEvents}\\
%
\hline
%
\op{Window\_DrawEvent} :-
  & \textit{Call}~\code{DeliverEventsToWindow}\\\hline
%
\end{tabular}
\end{center}

\mycaption{Fingerprints obtained by analyzing set equations in
\figref{figure:fingerprints} by applying \aref{algorithm:dynamic-fingerprint-mining} to the
labeled traces from \tabref{table:aid-experiments}.}
{\label{figure:fingerprints}}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END: Table with fingerprints.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%------------------------------------------------------------------------------
\section{Evaluation of the dynamic fingerprint mining algorithm}
\label{chapter:dynamic:evaluation}

We now evaluate the dynamic fingerprint mining algorithm, as implemented in
\aid, by answering four questions.

%
\subsection{How effective is \aid\ at locating fingerprints?} 
%
Raw traces generated by tangible-side effects have, on average, $53829$
code patterns. However, \aid\ abstracts each trace to the granularity of
functions: it first identifies fingerprints at the function level; if
necessary, it delves into the code patterns exercised by the function. The
number of distinct functions called in each trace is shown in the last row of
\tabref{table:aid-experiments}.  The third column of
\tabref{table:set-equations} shows, in terms of the number of functions, the
size of FP, which is the result obtained by computing the set equation for each
security-sensitive operation, to determine fingerprints. \aid\ was able to
achieve about one order of magnitude reduction in terms of the number of
distinct functions to be examined for fingerprints.

We examined each of the functions in FP to determine if it is indeed a
fingerprint. In most cases, we found that for a security-sensitive operation, a
single function in FP performs the operation.  However, in some cases, multiple
functions in FP seemed to perform the security-sensitive operation. For
example, both \textit{Call}~\code{MapWindow} and
\textit{Call}~\code{MapSubWindow}, which were present in FP, performed
\op{Window\_Map}. In such cases, we examined the execution traces of the server
to determine common code patterns exercised by the call to these functions.
Doing so for \op{Window\_Map} reveals that the common code patterns in
\code{MapWindow} and \code{MapSubWindow} are (\textit{Write} \pred{True}
\textit{to} \code{Window->mapped} $\wedge$ \textit{Write} \code{MapNotify}
\textit{to} \code{xEvent->union->type}). For security-sensitive operations such
as \op{Window\_InputEvent}, where we did not find common code patterns
exercised by candidate functions from FP, we deemed each of these function
calls to be fingerprints of the operation.
                 
\subsection{How precise are the fingerprints found?}
%
For each of the fingerprints recovered by \aid\ for the \xserver, we 
manually verified that it is indeed a fingerprint of the security-sensitive
operation in question. 

However, in general, \aid\ need not recover all fingerprints of a
security-sensitive operation. Because \aid\ employs dynamic program analysis,
it can only capture the fingerprints of a security-sensitive operation
exercised by the runtime traces, and may miss \textit{other} ways to perform
the operation. By collecting traces for a larger number of tangible
side-effects, and verifying the fingerprints collected by \aid\ against these
traces, confidence can be increased in the precision of fingerprints obtained
by \aid. 

\subsection{How much effort is involved in manual labeling of traces?}
%
In all, we collected $15$ traces for different tangible side-effects exercising
different \code{Window}-related security-sensitive operations. It took us a few
hours to manually label traces with security-sensitive operations.

\subsection{How effective is manual labeling of traces?}
%
In most cases, it is easy to reason about the security-sensitive operations
that are performed if a tangible side-effect is induced. However, because this
process is manual, we may miss security-sensitive operations that may be
performed (\my\ entries in \tabref{table:aid-experiments}), or erroneously
label a trace with security-sensitive operations that are not actually
performed (\mn\ entries). Our experience of manually labeling traces for the
\xserver\ shows that this process has an error rate of approximately $15\%$.

However, it must be noted that we were able to recover fingerprints 
\textit{in spite of labeling errors}. If a security-sensitive operation is
wrongly omitted from the labels of a trace that performs a tangible side-effect
associated with that operation (the \my\ case), then because the same
security-sensitive operation often appears in the labels of other traces, a
set equation can still be formulated for the operation, and the fingerprint can
be recovered. On the other hand, if a security-sensitive operation is wrongly
added to the labels of a trace (the \mn\ case), none of the functions in FP
will perform the tangible side-effect. In this case, trace labels are refined,
and the process is iterated until a fingerprint is identified.

%------------------------------------------------------------------------------
\section{Limitations}
\label{chapter:dynamic:limitations}

While the technique presented in this chapter was motivated by the need to
formalize descriptions of security-sensitive operations, it has three
limitations. 

\begin{enumerate}

\item The technique relies on the availability of high-level descriptions of
security-sensitive operations. While such descriptions are available for
several Linux subsystems and the \xserver, identifying security-sensitive
operations is, in general, an ad hoc and manual exercise, and it is not
realistic to assume that such descriptions will be available for all servers.

\item The technique relies on tangible side-effects to determine whether a
security-sensitive operation was performed during an execution of a server.
This is problematic for two reasons. 

First, it may not always be possible to identify tangible side-effects for a
security-sensitive operation. Indeed, in our experiments with the \xserver\
reported in this chapter, we faced difficulties in identifying tangible
side-effects for several security-sensitive operations.

Second, the technique relies on a human to manually perform controlled
experiments on the server, collect the runtime execution traces so generated,
and reason about the security-sensitive operations associated with each trace.
The accuracy and effectiveness of the technique is thus dependent on how
carefully the experiments were performed. For example, the \xserver\ permits
transparent windows, which can be mapped to the screen (thus inducing
\op{Window\_Map}). If such a transparent window is mapped to the screen during
one of the experiments, and the human fails to include \op{Window\_Map} in 
the label of the associated execution trace, the technique will fail to compute
a fingerprint for \op{Window\_Map}.

\item Finally, because the technique uses dynamic program analysis, it cannot
guarantee that all fingerprints of a security-sensitive operation have been
found, \ie~the technique is not \textit{complete}, and can have false
negatives. In particular, the number and quality of fingerprints mined by the
technique directly relies on the code coverage of the manually-induced
experiments.

\end{enumerate}

These limitations are fundamental, and prevented this technique from being
applied to a wide variety of servers. The static fingerprint mining technique
presented in the next chapter directly addresses these limitations of the
dynamic mining technique.


%------------------------------------------------------------------------------
\section{Using the dyamic fingerprint mining tool}
\label{chapter:dynamic:usage}

This section summarizes the steps that a security analyst must follow 
to find fingerprints using the dynamic fingerprint mining tool.

\begin{itemize}

\item Design a set of experiments to induce security-sensitive operations
in the server. Label each experiment with the set of security-sensitive
operations performed in that experiment.

\item Instrument the server to log accesses to sensitive data structures, 
conduct the experiments from the first step, and collect the traces emitted
by the server.

\item Compute set equations for each security-sensitive operation.

\item Apply set equations to traces and obtain pruned sets of code-patterns.

\item Manually examine and refine the pruned sets to identify fingerprints
of security-sensitive operations.

\end{itemize}


%------------------------------------------------------------------------------
\section{Summary of key ideas}
\label{chapter:dynamic:keyideas}

To summarize, the key contributions of this chapter are:

\begin{itemize}
\item The use of dynamic program analysis to convert high-level, informal
descriptions of security-sensitive operations into fingerprints.

\item The use of tangible side-effects as a means to determine whether an
execution of a server performs a security-sensitive operation.

\item An algorithm to localize fingerprints by comparing execution traces
using set equations.

\item An implementation of the above techniques in a prototype tool called
\aid, and its evaluation on the \xserver.

\end{itemize}
